# [Macro] &

## Syntax:

(& &body body) => result

## Arguments and Values:

body := forms

result := T

## Description:
Like CL:AND, & tests each form is not NIL.
When form is evaluated to NIL, assertion is signaled.
This is intended to be used in DEFSPEC, ?, or MAKE-REQUIREMENTS, especially :satisfies is specified as keyword.

Because with complex CL:AND form, we can not know which clause failed.

## Example:
```lisp
(? :foo :satisfies (lambda(x)
                     (and ; <--- when CL:AND is used...
		          (symbolp x)
		          (char= #\f (char (symbol-name x) 0))
			  (char= #\o (char (symbol-name x) 1))
			  (char= #\o (char (symbol-name x) 2)))))
;; we can only know CL:AND is failed.
; => (#S(TEST-ISSUE :FORM :FOO :EXPECTED NIL :ACTUAL :FOO
                    :POSITIONI NIL
		    :TEST (LAMBDA (X)
		            (AND (SYMBOLP X)
			         (CHAR= #\f (CHAR (SYMBOL-NAME X) 0))
				 (CHAR= #\o (CHAR (SYMBOL-NAME X) 1))
				 (CHAR= #\o (CHAR (SYMBOL-NAME X) 2))))))

(? :foo :satisfies (lambda(x)
                     (& ; <--- when & is used...
		        (symbolp x)
		        (char= #\f (char (symbol-name x) 0))
			(char= #\o (char (symbol-name x) 1))
			(char= #\o (char (symbol-name x) 2)))))
;; we can know which clause is failed.
; => (#S(UNSATISFIED-CLAUSE :FORM (CHAR= #\f (CHAR (SYMBOL-NAME X) 0))
                            :EXPECTED T :ACTUAL NIL
			    :POSITION NIL :ARGS (#\f #\F)))
```
## Affected-By:

## Side-Effects:

## Notes:

## Exceptional-Situations:

## See-Also:

?
DEFSPEC
ERROR-WAS-SIGNALED
MAKE-REQUIREMENT
